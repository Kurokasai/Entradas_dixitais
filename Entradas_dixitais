/*

Documentación simple do programa (02 - Entradas dixitais)
Autor: Brais Gude Martínez
Data: 20/01/2026
  
  Descrición: Este programa solicita ao usuario unha cor e un tempo a través do porto serie.
  Activa o LED correspondente nos pins 13 a 8 durante o tempo indicado.
  Xestiona erros se a cor non é válida.
  Un pulsador pausa o programa na primera pulsación. O resetea coa segunda.
  

*/

/* Configuración inicial e asignación do pin do pulsador con estado inicial en OFF e a función pra o reseteo. */
String cor = "";
float Tempo = -999.;
int pin = -99;
const int pinPulsador = 13;
bool estadoPulsador = false;
void(* resetFunc) (void) = 0;

void setup() {
  Serial.begin(9600);

/* Declaración de todos os pins. É necesario que teñan digitalWrite incluso
nos analóxicos para que reseteen completamente co pulsador xa que quedan "enganchados".

O pin do pulsador está declarado como entrada. Os LED como saídas. */
  
  pinMode(5, OUTPUT);
  digitalWrite(5, LOW);
  
  pinMode(3, OUTPUT);
  digitalWrite(3, LOW);
  
  pinMode(10, OUTPUT);
  digitalWrite(10, LOW);
  
  pinMode(11, OUTPUT);
  digitalWrite(11, LOW);

  pinMode(6, OUTPUT);
  digitalWrite(6, LOW);
  
  pinMode(9, OUTPUT);
  digitalWrite(9, LOW);
  
  pinMode(pinPulsador, INPUT);
}

/* Esta función interpreta o estado do pulsador. Ten un bucle de pausa coa primeira pulsación. Coa segunda pulsación
finalizase o bucle e se recurre á función de reseteo. */

void verificarPulsador() {
  if (digitalRead(pinPulsador) == HIGH) {
    
    if (digitalRead(pinPulsador) == HIGH) {
      if (!estadoPulsador) {
        estadoPulsador = true;
        Serial.println("Parouse o programa");
        
        while(digitalRead(pinPulsador) == HIGH) { delay(10); }
        
        while(true) {
          if (digitalRead(pinPulsador) == HIGH) {
             
             break;
          }
        }
      }
      
      Serial.println("Reiniciouse o programa");
      Serial.flush(); // Para evitar que se rompa a mensaxe tras resetear. 

      digitalWrite(5, LOW);
      digitalWrite(3, LOW);
      digitalWrite(10, LOW); // Había algún dos LED que se quedaba "enganchado" tras o reseteo. Isto asegura que se apaguen todos correctamente.
      digitalWrite(11, LOW);
      digitalWrite(6, LOW);
      digitalWrite(9, LOW);

      delay (500); // Delay necesario porque senón salta ao mismo tempo que á mensaxe de selección de cor 
      resetFunc();
    }
  }
}

/* Aquí dinme conta e costoume un huevo porque cando pulsabas como estaba antes a práctica (con delay)
o pulsador non respondía, non facía nada. Declarando isto o está checkeando todo o rato o estado actual
dos LED permitindo ao pulsador actuar.

millis é como un cronometro interno que conta dende que se encendeu arduino. Por iso uso unsigned long
xá que quedaría un número inmenso como pra poñer int. */

void esperar(float ms) {
  unsigned long tempoInicio = millis();
  while (millis() - tempoInicio < ms) {
    verificarPulsador();
  }
}

/* Aquí é donde está xá a práctic anterior das luces. Optimicei o switch case para que quedasen os pines
PWM e os que van a quedar como dixitais normais en bloque compacto en vez de ir un a un. En vez dun delay
se recurre a esperar. */

void loop(){
  while(Serial.available() > 0) { Serial.read(); } //Limpa o bufer.

  Serial.println("Dime a cor do LED que queres acender (azul, amarelo, branco, vermello, laranxa, verde):");
  
  while(Serial.available() == 0) { 
    verificarPulsador();
  }
  
  cor = Serial.readStringUntil('\n'); //Leese todo o escrito hasta pulsar Enter.
  cor.trim(); 
  
  Serial.println("Dime cantos segundos debe estar ON ou OFF");
  
  while(Serial.available() > 0) { Serial.read(); }
  
  while(Serial.available() == 0) { //Limpa o bufer.
    verificarPulsador();
  }
  
  Tempo = 1000 * Serial.parseFloat(); //Conversión a ms.
  
  if (cor == "verde")         {pin = 5;} //Lóxica para a selección das cores.
  else if (cor == "laranxa")  {pin = 3;}
  else if (cor == "amarelo")  {pin = 10;}
  else if (cor == "azul")     {pin = 11;}
  else if (cor == "vermello") {pin = 6;}
  else if (cor == "branco")   {pin = 9;}
  else                        {pin = -99;}
  
  switch (pin) {
    case 5: 
    case 3:
      
        digitalWrite(pin, HIGH); //Actuación en pin dixital con apagado e acendido.
        esperar(Tempo);
        digitalWrite(pin, LOW);
        esperar(Tempo);
    break; 
    
    case 10:
    case 11:
    case 6:
    case 9:
      for(int i = 0; i < 256; i++){ //Actuación en pin analóxico PWM (acendido).
        analogWrite(pin, i);
          esperar(Tempo/256); 
      }
      for(int i = 255; i >= 0; i--){ //Actuación en pin analóxico PWM (apagado).
        analogWrite(pin, i);
          esperar(Tempo/256); 
      }
    break;
    
    default: 
      Serial.println("A cor que me indicaches non existe"); //Xestión de erros.
      Serial.println("Escoller outra cor");
    break;  
   }
}
